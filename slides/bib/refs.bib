@article{MILNER1978348,
title = {A theory of type polymorphism in programming},
journal = {Journal of Computer and System Sciences},
volume = {17},
number = {3},
pages = {348-375},
year = {1978},
issn = {0022-0000},
doi = {https://doi.org/10.1016/0022-0000(78)90014-4},
url = {https://www.sciencedirect.com/science/article/pii/0022000078900144},
author = {Robin Milner},
abstract = {The aim of this work is largely a practical one. A widely employed style of programming, particularly in structure-processing languages which impose no discipline of types, entails defining procedures which work well on objects of a wide variety. We present a formal type discipline for such polymorphic procedures in the context of a simple programming language, and a compile time type-checking algorithm W which enforces the discipline. A Semantic Soundness Theorem (based on a formal semantics for the language) states that well-type programs cannot “go wrong” and a Syntactic Soundness Theorem states that if W accepts a program then it is well typed. We also discuss extending these results to richer languages; a type-checking algorithm based on W is in fact already implemented and working, for the metalanguage ML in the Edinburgh LCF system.}
}

@inproceedings{10.1145/96709.96748,
author = {Mairson, Harry G.},
title = {Deciding ML typability is complete for deterministic exponential time},
year = {1989},
isbn = {0897913434},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/96709.96748},
doi = {10.1145/96709.96748},
abstract = {A well known but incorrect piece of functional programming folklore is that ML expressions can be efficiently typed in polynomial time. In probing the truth of that folklore, various researchers, including Wand, Buneman, Kanellakis, and Mitchell, constructed simple counterexamples consisting of typable ML programs having length n, with principal types having Ω(2cn) distinct type variables and length Ω(22cn). When the types associated with these ML constructions were represented as directed acyclic graphs, their sizes grew as Ω(2cn). The folklore was even more strongly contradicted by the recent result of Kanellakis and Mitchell that simply deciding whether or not an ML expression is typable is PSPACE-hard.We improve the latter result, showing that deciding ML typability is DEXPTIME-hard. As Kanellakis and Mitchell have shown containment in DEXPTIME, the problem is DEXPTIME-complete. The proof of DEXPTIME-hardness is carried out via a generic reduction: it consists of a very straightforward simulation of any deterministic one-tape Turing machine M with input χ running in Ο(c|χ|) time by a polynomial-sized ML formula ΦM,χ, such that M accepts χ iff ΦM,χ is typable. The simulation of the transition function δ of the Turing Machine is realized uniquely through terms in the lambda calculus without the use of the polymorphic let construct. We use let for two purposes only: to generate an exponential amount of blank tape for the Turing Machine simulation to begin, and to compose an exponential number of applications of the ML formula simulating state transition.It is purely the expressive power of ML polymorphism to succinctly express function composition which results in a proof of DEXPTIME-hardness. We conjecture that lower bounds on deciding typability for extensions to the typed lambda calculus can be regarded precisely in terms of this expressive capacity for succinct function composition.To further understand this lower bound, we relate it to the problem of proving equality of type variables in a system of type equations generated from an ML expression with let-polymorphism. We show that given an oracle for solving this problem, deciding typability would be in PSPACE, as would be the actual computation of the principal type of the expression, were it indeed typable.},
booktitle = {Proceedings of the 17th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {382–401},
numpages = {20},
location = {San Francisco, California, USA},
series = {POPL '90}
}

@INPROCEEDINGS{316068,
  author={Wells, J.B.},
  booktitle={Proceedings Ninth Annual IEEE Symposium on Logic in Computer Science}, 
  title={Typability and type checking in the second-order /spl lambda/-calculus are equivalent and undecidable}, 
  year={1994},
  volume={},
  number={},
  pages={176-185},
  keywords={Logic programming;Calculus;Computer science;Helium},
  doi={10.1109/LICS.1994.316068}
}

@misc{gil2020tiesparametricallypolymorphictype,
      title={Ties between Parametrically Polymorphic Type Systems and Finite Control Automata}, 
      author={Joseph Gil and Ori Roth},
      year={2020},
      eprint={2009.04437},
      archivePrefix={arXiv},
      primaryClass={cs.PL},
      url={https://arxiv.org/abs/2009.04437}, 
}

@article{KNUTH1965607,
title = {On the translation of languages from left to right},
journal = {Information and Control},
volume = {8},
number = {6},
pages = {607-639},
year = {1965},
issn = {0019-9958},
doi = {https://doi.org/10.1016/S0019-9958(65)90426-2},
url = {https://www.sciencedirect.com/science/article/pii/S0019995865904262},
author = {Donald E. Knuth},
abstract = {There has been much recent interest in languages whose grammar is sufficiently simple that an efficient left-to-right parsing algorithm can be mechanically produced from the grammar. In this paper, we define LR(k) grammars, which are perhaps the most general ones of this type, and they provide the basis for understanding all of the special tricks which have been used in the construction of parsing algorithms for languages with simple structure, e.g. algebraic languages. We give algorithms for deciding if a given grammar satisfies the LR(k) condition, for given k, and also give methods for generating recognizes for LR(k) grammars. It is shown that the problem of whether or not a grammar is LR(k) for some k is undecidable, and the paper concludes by establishing various connections between LR(k) grammars and deterministic languages. In particular, the LR(k) condition is a natural analogue, for grammars, of the deterministic condition, for languages.}
}
