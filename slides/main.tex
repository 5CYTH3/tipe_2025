\documentclass{beamer}
\usetheme{Berkeley}
\definecolor{UBCblue}{RGB}{25,25,112} % UBC Blue (primary)
\usecolortheme[named=UBCblue]{structure}

\usepackage{ebproof}
\usepackage{forest}
\usepackage{simplebnf}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{tcolorbox}

\graphicspath{ {./res/} }

\setbeamertemplate{footline}[frame number]

\usefonttheme[onlymath]{serif}

%Information to be included in the title page:
\title{Optimisation de la vitesse de compilation par la fusion entre inférence de types et analyse syntaxique}
\author{Enogad Le Biavant--Frederic}
\institute{Alain René Lesage MPI}
\date{2025}

\begin{document}

\frame{\titlepage}

\section{Présentation générale}
\begin{frame}
		\frametitle{L'idée}
		Karm, 2022
		\begin{center}
				\includegraphics[scale=0.25]{repo}
		\end{center}
		Comment optimiser la vitesse de compilation en fusionnant analyse syntaxique et sémantique ?
		
\end{frame}

\begin{frame}[fragile]
		\frametitle{L'idée}

		$\Gamma = \{ 
				\only<1->{\texttt +: int \rightarrow int \rightarrow int}
				\only<2->{,\; \texttt x: \tau}
		\}$
		\\
		$\texttt{let} \; succ = \lambda x.(+ \; x \; 1)$
		
		\begin{columns}
				\begin{column}{0.5\textwidth}
						\begin{center}
						\begin{forest}
								for tree = {
										edge = {<-, semithick},
								}
								[succ
										[x]
										[+, name=spec +
												[x]
												[1]	
										]
								]
						\end{forest}
						\end{center}
				\end{column}
				\begin{column}{0.5\textwidth}
						\begin{center}
						\begin{forest}
								for tree = {
										edge = {<-, semithick},
								}
								[succ
								[x,edge label={node[midway, left]{\only<1->{$\{x:\tau\}$}}}]
										[+,edge label={node[midway, right]{\only<3->{$\{\tau = int\}$}}}
												[x, edge label={node[midway, left]{\only<2->{$\{x:\tau\}$}}}]
												[1]	
										]
								]
						\end{forest}
						\end{center}
				\end{column}
		\end{columns}
		\only<4>{Parsing récursif descendant}
\end{frame}

\section{Définitions}
\subsection{Parsing}
\begin{frame}
		\frametitle{Grammaire}
		\begin{bnf}
				$program$ ::= $expr$;;
				$expr$ ::= | $abs$ | $app$ | $letbinding$;;
				$app$ ::= $term$ [\{ $term$ \}];;
				$abs$ ::= "$\backslash$" $id\space$ "." $\space expr$;;
				$letbinding$ ::= "let" $id$ "=" $expr$ "in" $expr$;;
				$term$ ::= | \texttt{string} | \texttt{int} | \texttt{bool} | $id$ | "(" $expr$ ")"
		\end{bnf} 
\end{frame}

\subsection{Théorie des types}
\begin{frame}
		\frametitle{TT - Définitions}
		Définition de Type : classification de termes (Church).\\
		Théorie de travail : Lambda calcul simplement typé (LCST), polymorphique.\\
		\[
				\texttt{let\;} id = \lambda x.x :\forall \sigma\to\sigma
		\]
\end{frame}

\begin{frame}
\frametitle{Hindley-Milner}
		\[
		\begin{prooftree}
				\hypo{x:\sigma\in\Gamma}
				\infer1[var]{\Gamma \vdash x:\sigma}
		\end{prooftree}
		\]
		\newline
		\[
		\begin{prooftree}
				\hypo{\Gamma, x:\tau \vdash e:\tau'}
				\infer1[abs]{\Gamma \vdash \lambda x.e:\tau \to \tau'}
		\end{prooftree}
		\]
		\newline
		\[
		\begin{prooftree}
				\hypo{\Gamma \vdash f:\tau \to \tau'}
				\hypo{\Gamma \vdash e : \tau}
				\infer2[app]{\Gamma \vdash f\ e : \tau'}
		\end{prooftree}
		\]
\end{frame}

\begin{frame}
		\frametitle{Hindley-Milner}
		Algorithme W
		\begin{columns}
				\begin{column}{0.5\textwidth}
						\begin{enumerate}
								\item Assignation de variables de types aux expressions
								\item Génération de contraintes
								\item Substitutions
								\item Unification
								\item Instantiation, généralisation
						\end{enumerate}
				\end{column}
				\begin{column}{0.5\textwidth}
						\begin{forest}
								for tree = {
										edge = {<-, semithick},
								}
								[succ
								[x,edge label={node[midway, left]{$\{x:\tau\}$}}]
										[expr,edge label={node[midway, right]{$\{expr:\beta\}$}}
												[+,edge label={node[midway, left]{$\{\beta = int, \tau = int\}$}}
														[x, edge label={node[midway, left]{$\{x:\tau\}$}}]
														[1]	
												]
										]
								]
						\end{forest}
				\end{column}
		\end{columns}
\end{frame}

\section{Résultats}
\begin{frame}[t]
		\frametitle{Résultats}
		
		\begin{center}
				$\mathcal W : \tilde \Gamma \times Expr \to Subst \times Type$\\
				$\mathcal W^* : \tilde \Gamma \times L \to Subst \times \Gamma \times Expr \times L $	
		\end{center}
		
		Machine : i7 5th gen 3.00Ghz\\
		\vspace{5mm}
		Fichier de test : 1000 premiers nombres de church\\
		Version non optimisée : $\approx 26.37s$\\
		Version optimisée : $\approx 3.88s$\\
		\vspace{5mm}
		Fichier de test : 10K application de fonction successeur\\
		Version non optimisée : $\approx 1.48s$\\
		Version optimisée : $\approx 1.51s$
\end{frame}

\begin{frame}
		\frametitle{Résultats}
		\begin{center}
				% \includegraphics[scale=0.25]{graph}
		\end{center}
\end{frame}


\section{Conclusion}
\begin{frame}
		\frametitle{Conclusion}
		\begin{tcolorbox}[title=Bénéfices]
				Durée inférieure lorsque beaucoup d'unifications
		\end{tcolorbox}
		\begin{tcolorbox}
				Plus permissif envers les grammaires très imbriquées que les systèmes traditionnels
		\end{tcolorbox}
\end{frame}

\section{Formalisation}
\begin{frame}
		\frametitle{Formalisation}
		Automates d'arbres : $\mathcal A  = (\mathcal F, Q, Q_f, \Delta)$\\
		\begin{itemize}
				\item{$\mathcal F$ : Alphabet gradué (fonction d'arité $ar$) }
		\end{itemize}
		On peut décrire la grammaire comme une NRTG
\end{frame}


\section{Annexe}
\begin{frame}[fragile]
		\frametitle{Annexe}
		\begin{lstlisting}
			
		\end{lstlisting}
\end{frame}
\end{document}
